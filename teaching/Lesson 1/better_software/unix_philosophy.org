* UNIX 哲学
  Unix 哲学是自下而上的，而不是自上而下的。Unix 哲学注重实效，立足于丰富的经验。你不会在正规方法学和标准中找到它，它更接近于隐形的半本能的知识，即 UNIX 文化所传播的专业经验。
** 模块原则：使用简洁的接口拼合简单的部件
   - 计算机编程的本质就是控制复杂度。
   - 用清晰的接口把若干简单的模块组合成一个复杂软件。如此一来，多数问题只会局限于某个局部，那么就还有希望对局部进行改进而不至牵动全身。
 
** 清晰原则：清晰胜于机巧
   - 维护如此重要而成本如此高昂；在写程序时，要想到你不是写给执行代码的计算机看的，而是给人——将来阅读维护源码的人，包括你自己——看的。
 
** 组合原则：设计时考虑拼接组合
   - 在输入输出方面，Unix 传统极力提倡采用简单化、文本化、面向流、设备无关的格式。

** 分离原则：策略同机制分离，接口同引擎分离
** 简洁原则：设计要简洁，复杂度能低则低
   - 来自多方面的压力常常会使程序变得复杂，其中一种就是来自技术上的虚荣心理。
   - 过度的复杂性往往来自项目的要求，而这些要求常常基于当月的推销热点，而不是给予顾客的需求和软件实际能提供的功能。
   - 要避免这些陷阱，唯一的办法就是鼓励另一种软件文化，以简洁为美，人人对庞大复杂的东西群起而攻之——这是一个非常看重简单解决方案的工程传统，总是设法将程序系统分解为几个能够协作的小部分，并本能的抵制任何用过多噱头来粉饰程序的企图。
 
** 吝啬原则：除非别无他法，不要编写庞大的程序
** 透明性原则：设计要可见，以便审查和调试
   - 因为调试通常会占用四分之三甚至更多的开发时间，所以一开始就多做点工作以减少日后调试的工作量会很划算。一个特别有效的减少调试工作量的方法就是设计时充分考虑透明性和显见性。

** 健壮性：健壮源于透明和简洁
** 表示原则：把知识叠入数据以求逻辑质朴而健壮
   - 数据要比编程逻辑更容易驾驭。所以接下来，如果要在复杂数据和复杂代码中选择一个，宁愿选择前者。更进一步：在设计中，你应该主动将代码的复杂度转移到数据之中去。

** 通俗原则：接口设计避免标新立异
   - 最易用的程序就是用户需要学习新东西最少的程序——或者，换句话说，最易用的程序就是最切合用户已有知识的程序。

** 缄默原则：如果一个程序没有什么好说的，就保持沉默
** 补救原则：出现异常时，马上退出并给出足量错误信息
   - 软件要尽可能从容的应付各种错误输入和自身的运行错误。但是，如果做不到这一点，就让程序尽可能以一种容易诊断错误的方式终止。

** 经济原则：宁花机器一分，不花程序员一秒
** 生成原则：避免手工 hack，尽量编写程序去生成程序
** 优化原则：雕琢前先得有原型，跑之前先学会走
   - 90%的功能现在能实现，比 100%的功能永远实现不了强。做好原型设计可以帮助你避免为蝇头小利而投入过多的时间。
   - 先制作原型，再精雕细琢。优化之前先确保能用。
   - 先给你的设计做个未优化的、运行缓慢、很耗内存但是正确的实现，然后进行系统地调整，寻找那些可以通过牺牲最小局部简洁性而获得较大性能提升的地方。

** 多样原则：决不相信所谓的“不二法门”的断言
** 扩展原则：设计着眼未来，未来总比预想快
   - 要为数据格式和代码留下扩展的空间。
   - 设计协议或者文件格式时，应使其具有充分的自描述性以便可以扩展。

* 所有的 Unix 哲学浓缩为一条铁律
   KISS——Keep It Simple，Stupid!
